Documentation - Worker Management
====================

Workers are spawned by the command line but will also quit themselves automaticaly. This introduces the need to manage
these workers in an automated way.

For Linux there is a system called [supervisord](http://supervisord.org). Supervisord controls processes, will start
them automatically and restarts them when they are stopped. This part of the SlmQueue documentation does not fully
explain all features of supervisord, but it gives a kickstart for users who are in need of worker management.

If you prefer to use [systemd](https://wiki.freedesktop.org/www/Software/systemd/) instead skip down to the 
systemd sections.

supervisord: Basic configuration
--------------------------------

Supervisord has a configuration file under `/etc/supervisord/supervisord.conf`. There you define some basic settings, 
for example logging. Under `[unix_http_server]` and `[supervisorctl]` you have to define some required fields as well:

```ini
[supervisord]
logfile          = /var/log/supervisord/supervisord.log
logfile_maxbytes = 50MB
logfile_backups  = 10
loglevel         = error

[unix_http_server]
file             = /tmp/supervisor.sock

[supervisorctl]
serverurl        = unix:///tmp/supervisor.sock
```

supervisord: Worker configuration
---------------------------------

In supervisord, every process "group" it manages is sectioned under a `[program:x]` key. Here, `x` is the name of the 
program you want to manage. For using SlmQueue in your application, you might want to choose `my-app` as an appropriate
name.

```ini
[program:my-app]
command     = php /var/www/mysite/public/index.php queue beanstalkd default
user        = www-data
autorestart = true
```

For every program, at least the `command` line must be set, as supervisord must know which process it should manage.
Secondly, there are options to set e.g. the user under which the process will run, but there much more options available. All
options can be found at the [manual](http://supervisord.org/configuration.html) of supervisord.

When a process is killed, for example because the number of maximum runs is reached, it will exit. By default, the exit
code 0 is used. In this case, supervisord registers the killed process and starts a new process. Every time the PHP
script is stopped, supervisord makes sure a new process spawns again.

In case of an error or exception, the worker will probably be killed very soon. Supervisord checks for stop conditions
which occur within 1 second after the process started. If the process is killed within 1 second for 3 consequetive times,
supervisord stops respwaning the process. This event will be registered in the log of supervisord.

supervisord: Multiple workers
-----------------------------

When a large number of jobs are inserted into the queue, you might want to spin up more than one worker. Supervisord is 
capable of managing more processes of one program, under the key `numprocs`. Because be default, the process name is the
program name, you have to define the `process_name` as well, to distinguish the different processes.

```ini
[program:my-app]
user         = www-data
command      = php /var/www/mysite/public/index.php queue beanstalkd
numprocs     = 3
process_name = my-app-worker-%(process_num)
autorestart  = true
```

Alternative: systemd
-----------------------------------

Systemd is a new init system and comes pre-installed in Fedora, RHEL, Debian and their respective derivatives. 
It can be used to run worker continously with auto-restart and multiple instances.

Define your worker in a service file `/lib/systemd/system/my-app-worker.service`:
```ini
[Unit]
# Description of the service
Description=MyApp-Worker

# Add some other services / targets that you need before your worker can be started
# e. g. we need the network, mysql & redis server to work!
After=network.target mysqld.service redis-server.service

# If you have enabled auto-restarting (see below) systemd will stop restarting this service if it fails too often 
# Setting StartLimitIntervalSec to 0 disables this behavior.
StartLimitIntervalSec=0

[Service]
Type=simple

# Enable auto-restarting
Restart=always

# Wait 1 minute to restart the service after its exit
RestartSec=60

# set the correct user and group for the execution
User=www-data
Group=www-data

# You have to insert the correct server-specific directory here!
ExecStart=/usr/bin/php /var/www/mysite/public/index.php queue beanstalkd

[Install]
# Start this target after the multi-user.target is reached (if its enabled)
WantedBy=multi-user.target
```

You can manage your new service with these commands:
```bash
systemctl start   my-app-worker.service
systemctl status  my-app-worker.service
systemctl stop    my-app-worker.service
systemctl restart my-app-worker.service
 
systemctl enable my-app-worker.service # "enables" this service: this mean this service will be started on boot
```

systemd: using multiple workers
-------------------------------

If you want to use multiple workers there are some key differences.

Save your service file as `/lib/systemd/system/my-app-worker@.service` (mind the @) using this modified template:
```ini
[Unit]
# Description of the service with the worker ID in it
Description=MyApp-Worker %i

# If you have enabled auto-restarting (see below) systemd will stop restarting this service if it fails too often 
# Setting StartLimitIntervalSec to 0 disables this behavior.
StartLimitIntervalSec=0

# Make this worker a part of my-app.target
# This means when my-app.target is stopped or restarted, this worker will be stopped or restarted too. 
# But if this worker is stopped or restarted, it will not affect each other.
PartOf=my-app.target

[Service]
Type=simple

# Enable auto-restarting
Restart=always

# Wait 1 minute to restart the service after its exit
RestartSec=60

# set the correct user and group for the execution
User=www-data
Group=www-data

# You have to insert the correct server-specific directory here!
ExecStart=/usr/bin/php /var/www/mysite/public/index.php queue beanstalkd
```

Add a target file `/lib/systemd/system/my-app.target`:
```ini
[Unit]
# Add some other services / targets that you need before your worker can be started
# e. g. we need the network, mysql & redis server to work!
After=network.target mysqld.service redis-server.service

# This target want the workers to be started
# Add as many as you like
Wants=my-app-worker@1.service my-app-worker@2.service my-app-worker@3.service

[Install]
# Start this target after the multi-user.target is reached (if its enabled)
WantedBy=multi-user.target
```

Use these commands to manage your workers and the whole app:
```bash
# Start / stop one worker:
systemctl start   my-app-worker@1.service
systemctl status  my-app-worker@1.service
systemctl stop    my-app-worker@1.service
systemctl restart my-app-worker@1.service
# same with workers 2 and 3

# Start / stop all workers at the same time: 
systemctl start my-app.target
systemctl stop my-app.target
systemctl restart my-app.target

# Shows all workers and their status
systemctl list-dependencies my-app.target

# "enables" this target: this mean this target will be started on boot (and all workers in it too):
systemctl enable my-app.target 
```

More information can be found at [gunes.io: systemd vs supervisord](https://www.gunes.io/2017/08/24/systemd-vs-supervisor).

Navigation
----------

Previous page: [Events](6.Events.md)

1. [Introduction](1.Introduction.md)
2. [Configuration](2.Configuration.md)
3. [Jobs](3.Jobs.md)
4. [QueueAware](4.QueueAware.md)
5. [Workers](5.Workers.md)
6. [Events](6.Events.md)
7. [Worker management](7.WorkerManagement.md)
